#!/usr/bin/perl
#TODO:
#   X trick-CP Makefile_Src loop
#   x Fix S_define including S_source.hh as dep
#   perl errors not logged from gui
#   X remove redundant env variables
#   x what happens if no s_overrides? Check other fields for good measure.
#   verify building with dirs+exclusion / s_Define+filter works
#   consider applying this logic: if ( $path =~ /^\Q$exclude_path\E(.*)/ or abs_path($path) =~ /^\Q$exclude_path\E(.*)/ )
#   x add S_defined libs to TRICK_EXT_LIB_DIRS
#   x     Just do filter and make it mandatory? Is there ever a scenario where the filter isn't necessary?
#   find_file_by_ext alreayd handles full file paths, make sure the whole system does and allow the source/header dirs to be files
#   x utilize remove_redundant_paths?
#   refine compilation options, make sure equivalent to a normal trick build
#   x split s_define/dirs build methods in GUI into separate panels
#   x Consider removing the separate src/header dirs and consolidating into dir
#   x If a trickified lib exists, and is referenced via the S_overrides, subsequent sim builds (and trickify) rebuilds can generate a botched trickify_deps
#       x include a if AM_I_TRICKIFYING guard in the trickify s_overrides
#       x !!! NEw plan for handling the trick_deps/build problem: Move build dir, run partial trickCP, delete tmp build, move old build back
#           Need to handle cleanup on failure
#           x Need to clean more gracefully. Remove all artifacts w/o make clean
#   Make build printing more useful. Color code, more info behind verbose
#   x getting a strange issue in when building with a clean trick-cp/trickify in fish, getting cat fails on io and py link lists
#   x progress bar
#   x Add filter excludes to gui
#   X Documenation note: Make sure your build dir is not under the exclude
#   Mr Penn mascot
#   make sure dirs are used correctly if user does not provide a trailing /
#   x make one exclude on the gui shared between both tabs
#   If S_overrides contains relative paths, var dump can potentially break. Do not see any easy workaround to this, needs build redirecting to resolve
#   trickify.mk will generate swig/icg files for any #include dependencies. This can result in unexpected swig/icg files being included in the build. Notes:
#       Appears that the trickified lib swig/icg takes precedence, potentially causes mismatches with the actual .h class definition
#       Currently generate a list of these files, what to do about it?
#   When rebuilding ontop of an existing trickified lib, full file list doesnt seem to fully populate
#   NOTES FOR REBUILDING:
#       must consider possibility of scope change
#           trickify check should be first thing in trick-CP, in case new things need to be pulled in
#           is it possible an included file changing could trigger a need for a rebuild? Need investigation
#               Yes, need to establish what files ICG/SWIG exclude.
#                   system? - yes, do not trigger sim rebuilds
#                   trick library files? - not only appear to be excluded, do no trigger sim rebuilds
#                   icg/swig excluded? - these are excluded from swig/icg lists, but DO trigger rebuilds
#       Need to rework main script to support rebuild
#           since rebuild will occur mid trick-CP, need to be careful about how we stomp on makefiles and whatnot included by trick-CP
#               perhaps add a distinct make call in the trick-CP itself before the main makefile, keep trickify separated. This would be more akin to a manual trickify build, where it is a separate process done beforehand
#       need a way to control autorebuilding, evn or something
#   In documentation, make notes about lib name being used for makefile rule generation, and the potential conflicts of using the same name multiple times
#   verify autorebuild is not polluted bu env vars


use warnings ;
use strict ;

#store the base env from the shell
#need to restore the env later to run S_overrides.mk in a clean environment
our %SHELL_ENV = %ENV;

our $my_path;
BEGIN
{
    $my_path = $0 ;
    $my_path =~ s/trick-ify// ;
}

use File::Basename ;
use File::Find ;
use File::Path qw(make_path);
use Getopt::Long ;
use Cwd ;
use lib "$my_path../libexec/trick/pm" ;
use get_makefile_vars ;

sub find_file_by_ext($$)
{
    my ($dirs_ref, $ext) = @_ ;
    our @files_found = ();
    my $wanted = sub
    {
        if($_ =~ /\Q$ext\E$/)
        {
            push @files_found, $File::Find::name ;
        }
    };
    find($wanted, @$dirs_ref);
}
our @files_found ;

sub exclude_paths($$)
{
    my ($file_refs, $excl) = @_ ;
    my @pruned_list ;
    foreach my $file (@$file_refs)
    {
        if(($file =~ /^\Q$excl\E/) ne 1)
        {
            push @pruned_list, $file ;
        }
    }
    @$file_refs = @pruned_list ;
}

sub filter_paths($$)
{
    my ($file_refs, $filters) = @_ ;
    if(@$filters eq 0)
    {
       return 0 ;
    }

    my @pruned_list ;
    foreach my $file (@$file_refs)
    {
        my $include = 0 ;
        foreach my $filter (@$filters)
        {
            if(($file =~ /^\Q$filter\E/) eq 1)
            {
                $include = 1 ;
            }
        }

        if($include)
        {
            push @pruned_list, $file ;
        }
    }
    @$file_refs = @pruned_list ;
}

our @header_ext = (".h", ".hh", ".hpp", ".H", ".hxx", ".h++") ;
our @source_ext_cpp = (".cpp", ".cc", ".cxx", ".c++") ;
our @source_ext_c   = (".c", ".C") ;
our @source_ext     = (@source_ext_cpp, @source_ext_c) ;
our @trick_build_files = ("build/", "buildmodels/", "DP_Product/", "makefile", "python", "S_main_Linux_8.5_x86_64.exe", "S_sie.resource", "S_source.hh", "trick.zip", ".trick") ;
our $tmp_trick_build = "trickifying_tmp" ;

#Variables to store cmd line args
my $build_dir = getcwd ;                                                     # Where to build trickify artifacts
my $source_dirs = "" ;                                                       # User source code directories
my $source_make_call = "" ;                                                  # Make call to build object files
my $source_make_args = "" ;                                                  # Args to pass into default object make
my $trickify_make_args = "" ;                                                # Arguments to pass into the trickify make
my $trickify_make_path = "$my_path../share/trick/makefiles/" ;               # Path of the trickify make file
my $full_build = 1 ;                                                         # Whether to build only ICG/Swig artifacts or entire source
my $name = "trickified" ;                                                    # Name of the library
my $build_type = "o" ;                                                       # Type of library to be built (o, a , so)
my $debug = 0 ;                                                              # Debug info flag
my $trick_home = "$my_path.." ;                                              # Trick directory to use for building
my $no_source_build = 0 ;                                                    # Arg to disable building source files
my $no_clean_obj = 0 ;                                                       # Don't rebuild trickify_obj_list
my $no_clean_src = 0 ;                                                       # Don't rebuild trickify_src_list
my $no_clean_s_source = 0 ;                                                  # Don't rebuild S_source.hh
my $s_overrides = "" ;                                                       # Optional S_override make file
my $include = "" ;                                                           # Directories to include when building source/ICG/SWIG files
my $exclude_arg = "" ;                                                       # Directories to exclude from trickification
my $s_define = "" ;                                                          # S_define to pull files from
my $s_define_filter = "" ;                                                   # Only use files from the S_define under these dirs

our $stage = 1;
sub logStage()
{
    open my $fh, '>>', "$build_dir/trickify_stage_$stage" ;
    $stage++ ;
}

#Re-create the command line call
our @cmdline ;
push @cmdline, basename($0) ;
foreach my $arg (@ARGV)
{
    push @cmdline, $arg ;
}
our $cmdline = join ' ', @cmdline ;

#Process cmd line args
our %cmd_args ;
our @cmd_args ;
$cmd_args{"d=s"}                        = \$source_dirs;                    # User source code directories
$cmd_args{"no_clean_s_source"}          = \$no_clean_s_source;              # Don't rebuild S_source.hh
$cmd_args{"no_clean_src_list"}          = \$no_clean_src;                   # Don't rebuild trickify_src_list
$cmd_args{"no_clean_obj_list"}          = \$no_clean_obj;                   # Don't rebuild trickify_obj_list
$cmd_args{"no_source"}                  = \$no_source_build;                # Arg to disable building source files
$cmd_args{"source_make=s"}              = \$source_make_call;               # Make call to build object files
$cmd_args{"source_make_args=s"}         = \$source_make_args;               # Default make call args to build object files
$cmd_args{"trickify_args=s"}            = \$trickify_make_args;             # Trickify make args
$cmd_args{"trickify_make=s"}            = \$trickify_make_path;             # Set trickify make path
$cmd_args{"n=s"}                        = \$name;                           # Set the library name
$cmd_args{"b=s"}                        = \$build_type;                     # Set library build type
$cmd_args{"v"}                          = \$debug;                          # Verbose, print debug info
$cmd_args{"trick_home=s"}               = \$trick_home;                     # Set trick home directory
$cmd_args{"s_overrides=s"}              = \$s_overrides;                    # Optional S_override make file
$cmd_args{"include=s"}                  = \$include;                        # Directories to include when building source/ICG/SWIG files
$cmd_args{"ex=s"}                       = \$exclude_arg;                    # Directories to exclude from trickification
$cmd_args{"build=s"}                    = \$build_dir;                      # Where to build trickify artifacts
$cmd_args{"s_define=s"}                 = \$s_define;                       # S_define to pull files from
$cmd_args{"s_define_filter=s"}          = \$s_define_filter;                # Only use files from the S_define under these dirs
foreach my $arg (sort keys %cmd_args)
{
    push @cmd_args, $arg ;
    push @cmd_args, $cmd_args{$arg} ;
}
GetOptions(@cmd_args) ;

# If we are trickifying, tells trick-CP to stop after trickify_deps is built
$ENV{'AM_I_TRICKIFYING'} = 1 ;
logStage(); #Stage 1

# Ensure build dir exists
unless(-d $build_dir)
{
    make_path($build_dir) or die "Could not create build dir: $build_dir, $!\n";
}

# If user provided an S_define, run a partial trick-CP and retrieve the lib dependencies
my $s_define_dir = "" ;
my @lib_deps_header;
my @lib_deps_source;
if($s_define ne "")
{
    $s_define_dir = dirname($s_define) ;
    chdir Cwd::abs_path($s_define_dir) or die "Error changing to the s_define directory: $s_define_dir\n" ;
    
    # If the user has already built the sim, push it somewhere else
    map 
    {
        if(-e $_)
        {
            system("mv $_ $tmp_trick_build$_") == 0 or die "Could not move $_\n" ;
        }
    }
    @trick_build_files;    

    my $cmd_ret = `$my_path/trick-CP 2>&1` ;
    if($cmd_ret ne "") 
    {
        print "$cmd_ret" ;
    }
    -e "build/trickify_deps" or die "Failed to create trickify_deps from S_define.\n" ;

    open (my $fh, "build/trickify_deps") or die "Could not open trickify_deps" ;
    while (my $line = <$fh>) 
    {
        chomp $line ;
        if($line =~ /\QS_source.hh\E$/)
        {
            next ;
        }
        if(scalar grep {$line =~ /\Q$_\E$/} @source_ext)
        {
            push @lib_deps_source, $line ;
        }
        else
        {
            push @lib_deps_header, $line ;
        }
    }
    close ($fh) ;

    # Clear up the partial build dir we just made
    system("make clean") == 0 or die "Could not clean up tmp build dir\n" ;

    map 
    {
        if(-e "$tmp_trick_build$_")
        {
            system("mv $tmp_trick_build$_ $_") == 0 or die "Could not move $_\n" ;
        }
    }
    @trick_build_files; 
}
my @filters = split ' ', $s_define_filter ;
filter_paths(\@lib_deps_source, \@filters) ;
filter_paths(\@lib_deps_header, \@filters) ;

chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;

# Split the s_overrides path into a dir and file name
my $s_overrides_dir  = "" ;
if ($s_overrides ne "")
{
    $s_overrides_dir  = dirname($s_overrides) ;
}

$full_build = !$no_source_build ;

if( !(($build_type eq "o") or ($build_type eq "a") or ($build_type eq "so") or ($build_type eq "dylib")) )
{
    print "Invalid build type {$build_type}, valid build types are {o, a, so}\n" ;
    exit 1 ;
}

if($s_define eq "")
{
    if($source_dirs eq "" and $full_build)
    {
        print "Must provide source directories or S_define\n" ;
        exit 1 ;
    }
}

#Build list of includes for compilation.
my $include_arg = "";
my @incl_dirs = split ' ', $include ;
foreach my $dir (@incl_dirs)
{
    $include_arg .= "-I$dir " ;
}

#Set Environment Variables
if ($full_build)
{
    $ENV{'FULL_TRICKIFY_BUILD'} = "1" ;
}
my @src_dirs = split ' ', $source_dirs ;
my $source_dir_args = "" ;
foreach my $dir (@src_dirs)
{
    $source_dir_args .= "-I" . $dir . " " ;
}
$ENV{'TRICKIFY_CXX_FLAGS'} = "$source_dir_args -I$trick_home -I$trick_home/include/trick/compat -I${trick_home}/include -I$trick_home/trick_source -I$trick_home/trick_source/er7_utils -I$trick_home/trick_source/er7_utils $include_arg " . $ENV{"TRICK_CFLAGS"} . " " . $ENV{"TRICK_CXXFLAGS"} ;
$ENV{'TRICKIFY_OBJECT_NAME'} = "$build_dir/$name.$build_type" ;
$ENV{'TRICKIFY_BUILD'} = "$build_dir/" ;
$ENV{'TRICKIFY_PYTHON_DIR'} = "$build_dir/python" ;
$ENV{'TRICKIFY_S_OVERRIDES'} = "$s_overrides" ;
our @exclude_list = split ' ', $exclude_arg ;
if ( $build_type eq "o" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "PLO" ;
}
elsif ( $build_type eq "a" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "STATIC" ;
}
elsif ( $build_type eq "so" || $build_type eq "dylib" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "SHARED" ;
    if ($^O eq "linux")
    {
        $source_make_args .= " -fPIC" ;
    }
}

#Build the S_overrides_trickify.mk
print "Building S_overrides_trickify.mk\n" ;  
my $ext_lib_dir ;
$ext_lib_dir    .= join '', (map {":$_"} (split ' ', $source_dirs)) ;
$ext_lib_dir    .= join '', (map {":$_"} @filters) ;
my $ext_lib_dir_overrides = join '', (map {":$_"} @exclude_list) ;

#if the user provides an s_define, we automatically exclude that dir from ext_lib_dirs
if ($s_define_dir ne "")
{
    push @exclude_list, "$s_define_dir/build/" ;
    push @exclude_list, "$s_define_dir/S_source.hh" ;
}

my $my_cwd = getcwd;
#TODO: Might want to add an option to make this a relative path.        
open (my $fh, ">", "S_overrides_trickify.mk") or die "Could not open S_overrides_trickify.mk\n" ;
print $fh "ifndef AM_I_TRICKIFYING\n" ;  # Only want these parameters if we are doing normal sim builds, otherwise the ext libs will butcher the trickify_deps
print $fh "LOCAL_DIR := \$(abspath \$(dir \$(lastword \$(MAKEFILE_LIST))))\n\n" ;
print $fh "include $build_dir/trickify_dep_list\n\n" ;
print $fh "TRICK_LDFLAGS += " . Cwd::abs_path($ENV{'TRICKIFY_OBJECT_NAME'}) . "\n" ;
print $fh "TRICK_EXT_LIB_DIRS += $ext_lib_dir\n" ;
print $fh "TRICK_EXT_LIB_DIRS_OVERRIDES += ",$ext_lib_dir_overrides ,"\n" ;
print $fh "TRICK_PYTHON_PATH += :" . $my_cwd . "/python\n" ;
print $fh "TRICK_SWIG_FLAGS += -I" . $my_cwd . "\n" ;
print $fh "\nclean_trickify_$name:\n" ;
print $fh "\t-make -C \$(LOCAL_DIR) clean_trickify\n" ;
print $fh "\nclean_trickify: clean_trickify_$name\n" ;
print $fh "\nnuke_trickify_$name:\n" ;
print $fh "\t-make -C \$(LOCAL_DIR) nuke_trickify\n" ;
print $fh "\nnuke_trickify: nuke_trickify_$name\n" ;
print $fh "\nrebuild_trickify:: $build_dir/$name.$build_type\n" ;
print $fh "\nendif\n" ;
close ($fh) ;

open ($fh, ">", "makefile") or die "Could not create makefile\n" ;
print $fh "LOCAL_DIR := \$(abspath \$(dir \$(lastword \$(MAKEFILE_LIST))))\n" ;
print $fh "\nclean_trickify:\n" ;
print $fh "\t-rm -rf build .trick\n" ;
print $fh "\t-rm S_source.hh\n" ;
print $fh "\t-rm trickify_obj_list\n" ;
print $fh "\t-rm trickify_src_list\n" ;
print $fh "\t-rm trickify_stage_*\n" ;
print $fh "\t-rm trickify.log\n" ;
print $fh "\t-rm get_vars.mk\n" ;
print $fh "\t-rm var_dump.mk\n" ;
print $fh "\nnuke_trickify: clean_trickify\n" ;
print $fh "\t-rm python\n" ;
print $fh "\t-rm S_overrides_trickify.mk\n" ;
print $fh "\t-rm *.a\n" ;
print $fh "\t-rm *.o\n" ;
print $fh "\t-rm *.so\n" ;
print $fh "\t-rm makefile\n" ;
print $fh "\t-rm *.mk\n" ;
print $fh "\t-rm *_list\n" ;
print $fh "\nrebuild_trickify: \n" ;
print $fh "\t$cmdline" ;
close ($fh) ;


#Build the S_source.hh
if (!$no_clean_s_source)
{
    print "Building S_source.hh\n" ;

    my @make_s_source ;
    my @headers = split ' ', $source_dirs ;
    foreach my $ext (@header_ext)
    {
        find_file_by_ext(\@headers, $ext) ;
        push @make_s_source, @files_found ;
    }
    push @make_s_source, @lib_deps_header ;

    foreach my $excl (@exclude_list)
    {
        exclude_paths(\@make_s_source, $excl) ;
    }

    open (my $fh, ">", "S_source.hh") or die "Could not open S_source.hh\n" ;
    foreach my $header (@make_s_source)
    {
        print $fh "#include \"$header\"\n" ;
    } 
}

#Build source file list, only if trickifying the entire library
if (!$no_clean_src and $full_build)
{
    print "Building trickify_src_list\n" ;

    my @make_src_list ;
    my @sources = split ' ', $source_dirs ;
    foreach my $ext (@source_ext)
    {
        find_file_by_ext(\@sources, $ext) ;
        push @make_src_list, @files_found ;
    }
    push @make_src_list, @lib_deps_source ;

    foreach my $excl (@exclude_list)
    {
        exclude_paths(\@make_src_list, $excl) ;
    }

    open (my $fh, ">", "trickify_src_list") or die "Could not open trickify_src_list\n" ;
    foreach my $source (@make_src_list)
    {
        print $fh "$source\n" ;
    }
}

#Build array of source files
#We need to read in the file we just wrote to, because there is a no_clean_src option
my @src_files ;
if ($full_build)
{
    open (my $fh, "trickify_src_list") or die "Could not open trickify_src_list: $!" ;
    while (my $line = <$fh>) 
    {
        chomp $line ;
        push @src_files, $line ;
    }
    close ($fh) ;
}
logStage(); #Stage 2

#Build object files from source file list
if ($full_build)
{
    print "Building object files\n" ;
    if($source_make_call eq "")
    {
        # Create a makefile for building source files
        open (my $fh, ">", "trickify_src.mk") or die "Could not open trickify_src.mk: $!" ;
        print $fh "ifneq (\$(TRICKIFY_S_OVERRIDES),)\n" ;
        print $fh "\tinclude \$(TRICKIFY_S_OVERRIDES)\n" ;
        print $fh "endif\n\n" ;
        print $fh "include ${trickify_make_path}/Makefile.common\n\n" ;
        print $fh ".SECONDEXPANSION:\n\n" ;

        $ENV{'TRICKIFY_SRC_MAKE_ARGS'} = $source_make_args ;

        my %files_by_ext;
        foreach my $src (@src_files)
        {
            $src =~ /^([\w\W]*\/)([\w\W^\/]*)$/ ;
            my $path = $1 ;
            my $file = $2 ;

            #create build directory
            make_path("build$path") ;
            -e "build$path" or die "Could not create dir: build$path, $!\n";

            #Determine extension
            $src =~ /^([^\s]*)(\.[^\s]*)$/ ; 
            my $ext = $2 ;
            grep { /^\Q$ext\E$/ } @source_ext or die "Invalid extension on $src: $ext\n" ;
            push @{$files_by_ext{$ext}}, $1 ;
        }
        foreach my $ext (keys %files_by_ext)
        {
            print $fh "TRICKIFY_OBJECTS$ext :=  \\\n" ;
            foreach my $src (@{$files_by_ext{$ext}})
            {
                print $fh "\t$build_dir/build$src.o \\\n" ;
            }

            if( grep { /^\Q$ext\E$/ } @source_ext_cpp )
            {
                print $fh "\n\${TRICKIFY_OBJECTS$ext} : $build_dir/build/%.o : /%$ext | \$\$(dir \$\$@)\n" ;
                print $fh "\t\$(TRICK_CXX) \$(TRICKIFY_SRC_MAKE_ARGS) \$(TRICKIFY_CXX_FLAGS) \$(TRICK_CFLAGS) \$(TRICK_SFLAGS) \$(TRICK_CXXFLAGS) \$(TRICK_SYSTEM_CXXFLAGS) -c -o \$@ \$<\n" ;
            }
            else
            {
                print $fh "\n\${TRICKIFY_OBJECTS$ext} : $build_dir/build/%.o : /%.cc | \$\$(dir \$\$@)\n" ;
                print $fh "\t\$(TRICK_CC) \$(TRICKIFY_SRC_MAKE_ARGS) \$(TRICKIFY_CXX_FLAGS) \$(TRICK_CFLAGS) \$(TRICK_SFLAGS) \$(TRICK_CXXFLAGS) \$(TRICK_SYSTEM_CXXFLAGS) -c -o \$@ \$<\n" ;
            }
        }

        print $fh "\ntrickify_make:" ;
        foreach my $ext (keys %files_by_ext)
        {
            print $fh " \$(TRICKIFY_OBJECTS$ext)" ;
        }
        close ($fh) ;

        #If an s_overrides.mk is provided we need to build in that dir to preserve relative make paths
        if($s_overrides_dir ne "")
        {
            chdir Cwd::abs_path($s_overrides_dir) or die "Error changing to s_overrides directory: $s_overrides_dir\n" ;
        }

        my $cmd = "make trickify_make -f $build_dir/trickify_src.mk" ;
        my $cmd_ret = `$cmd 2>&1` ;
        if($cmd_ret ne "") 
        {
            print "$cmd_ret" ;
        }
        chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;
    }
    else
    {
        print(`$source_make_call`) ;
    }
}

#Build object file list, only if trickifying the entire library
if(!$no_clean_obj and $full_build)
{
    print "Building trickify_obj_list\n" ;
    #Create list of source file names without dirs and extensions
    my @src_files_base ;
    foreach my $src (@src_files)
    {
        $src =~ s/\..*$// ;
        push @src_files_base, basename($src) ;
    }

    #Create a list of all .o files under build
    my @make_obj_list ;
    my @build_dir = getcwd ;
    find_file_by_ext(\@build_dir, ".o") ;
    push @make_obj_list, @files_found ;

    open (my $fh, ">", "trickify_obj_list") or die "Could not open trickify_obj_list\n" ;
    foreach my $obj (@make_obj_list)
    {
        #remove the dir and extension
        $obj =~ /^(.+?)\Q.o\E$/ ;
        my $raw_filename = $1 ;
        $raw_filename = basename($raw_filename) ;
        
        #only write .o that have a matching source file
        #this ensures we don't grab swig and icg .o artifacts twice, those are pulled in later
        my @is_present = grep (/\Q$raw_filename\E/, @src_files_base) ;
        if(@is_present ne 0)
        {
            print $fh "$obj\n" ;
        }
    } 
}
logStage(); #Stage 3

#Build trickify call
print "Begin Trickification...\n" ;
if($s_overrides_dir ne "")
{
    chdir Cwd::abs_path($s_overrides_dir) or die "Error changing to s_overrides directory: $s_overrides_dir\n" ;
    dump_makefile_vars($s_overrides, $build_dir, \%SHELL_ENV, ("TRICKIFY_BUILD_TYPE", "TRICKIFY_OBJECT_NAME", "TRICKIFY_PYTHON_DIR", "TRICK_CFLAGS", "TRICK_CXXFLAGS")) ; 
    chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;
    $ENV{"TRICKIFY_MAKE_DUMP"} = Cwd::abs_path("var_dump.mk") ;
}
my $trickify_make_call = "make $trickify_make_args -f $trickify_make_path/trickify.mk trickify" ;
my $cmd_ret = `$trickify_make_call 2>&1` ;
my $cmd_exit_code = $? ;
if($cmd_ret ne "") 
{
    print "$cmd_ret" ;
}

logStage(); #Stage 4

#The full file list is dumped as one line. We need to clean it up (don't want to do that in bash lol)
open ($fh, '<', "full_file_list") or die "Could not open full_file_list: $!" ;
my $line = <$fh> ;
chomp $line ;
my @full_file_list = split ' ', $line ;
close ($fh) ;

#py and io link lists use relative paths (start with build/)
#obj file list uses full file paths
#need to make them similar
@full_file_list = map 
{
    my $ret = $_ ;
    if( $_ !~ /^\Qbuild\/\E/ )
    {
        /^(.*)(\Qbuild\/\E.*)$/ ;
       $ret =  $2 ;
    }
    $ret ;
} 
(@full_file_list) ;

open ($fh, '>', "full_file_list") or die "Could not open full_file_list: $!" ;
map { print $fh "$_\n" } @full_file_list ;
close ($fh) ;


#Generate dependency list
#We need to generate a dependency list for the trickified lib
#All explicity declared files are included, along with all their non-trick/system #include
#We piggyback off of ICG's lists to track all #include in the lib
my %trickify_dep_list;
my @dep_lists = ("trickify_src_list", "build/ICG_processed", "build/ICG_no_found");
foreach my $list (@dep_lists)
{
    open ($fh, $list) or die "Could not open $list: $!" ;
    while (my $line = <$fh>) 
    {
        chomp $line ;
        if($line !~ /\QS_source.hh\E$/)
        {
            $trickify_dep_list{$line} = 1 ;
        }
    }
    close ($fh) ;
}

open ($fh, '>', "trickify_dep_list") or die "Could not open trickify_dep_list: $!" ;
print $fh "LOCAL_DIR := \$(abspath \$(dir \$(lastword \$(MAKEFILE_LIST))))\n\n" ;
print $fh "$build_dir/$name.$build_type: \\\n" ;
map { print $fh "\t$_\\\n" } (sort keys %trickify_dep_list) ;
print $fh "\n\t-make -C \$(LOCAL_DIR) rebuild_trickify\n" ;
close ($fh) ;

#look for files outside the selected dirs/s_define filter
my @extra_file_list = grep 
{
    my $ret = 0 ;
    s/^\Qbuild\E//; #strip the leading build from the file path
    my $file = $_ ;
    my @valid_dirs = ((split ' ', $s_define_filter), (split ' ', $source_dirs)) ; #all paths provided by the user for source

    #if the file does not start with a s_define filter or source dir
    if( (grep { $file =~ /^\Q$_\E/ } (@valid_dirs)) == 0 )
    {
        $ret = 1 ;
    }

    #if the file starts with an excluded path
    if( grep { $file =~ /^\Q$_\E/ } (split ' ', $exclude_arg) )
    {
        $ret = 1 ;
    }

    $ret;
} 
(sort keys %trickify_dep_list) ;

open ($fh, '>', "extra_file_list") or die "Could not open full_file_list: $!" ;
map { print $fh "$_\n" } @extra_file_list ;
close ($fh) ;

if($debug) {
    print 
   "TRICKIFY BUILD INFO:
    source_dirs = $source_dirs
    source_make_call = $source_make_call
    trickify_make_args = $trickify_make_args
    trickify_make_path = $trickify_make_path
    build_s_source = $no_clean_s_source
    full_build = $full_build
    name = $name
    build_type = $build_type
    trick_home = $trick_home
    TRICKIFY_CXX_FLAGS = $ENV{'TRICKIFY_CXX_FLAGS'}\n" ;
}

if($cmd_exit_code != 0)
{
    die $cmd_exit_code ;
}
