#!/usr/bin/perl
#TODO:
#   X trick-CP Makefile_Src loop
#   x Fix S_define including S_source.hh as dep
#   perl errors not logged from gui
#   X remove redundant env variables
#   x what happens if no s_overrides? Check other fields for good measure.
#   verify building with dirs+exclusion / s_Define+filter works
#   consider applying this logic: if ( $path =~ /^\Q$exclude_path\E(.*)/ or abs_path($path) =~ /^\Q$exclude_path\E(.*)/ )
#   x add S_defined libs to TRICK_EXT_LIB_DIRS
#   x     Just do filter and make it mandatory? Is there ever a scenario where the filter isn't necessary?
#   find_file_by_ext alreayd handles full file paths, make sure the whole system does and allow the source/header dirs to be files
#   x utilize remove_redundant_paths?
#   refine compilation options, make sure equivalent to a normal trick build
#   x split s_define/dirs build methods in GUI into separate panels
#   x Consider removing the separate src/header dirs and consolidating into dir
#   x If a trickified lib exists, and is referenced via the S_overrides, subsequent sim builds (and trickify) rebuilds can generate a botched trickify_deps
#       x include a if AM_I_TRICKIFYING guard in the trickify s_overrides
#       x !!! NEw plan for handling the trick_deps/build problem: Move build dir, run partial trickCP, delete tmp build, move old build back
#           Need to handle cleanup on failure
#           x Need to clean more gracefully. Remove all artifacts w/o make clean
#   Make build printing more useful. Color code, more info behind verbose
#   x getting a strange issue in when building with a clean trick-cp/trickify in fish, getting cat fails on io and py link lists
#   x progress bar
#   x Add filter excludes to gui
#   X Documenation note: Make sure your build dir is not under the exclude
#   Mr Penn mascot
#   make sure dirs are used correctly if user does not provide a trailing /
#   x make one exclude on the gui shared between both tabs

use warnings ;
use strict ;

#store the base env from the shell
#need to restore the env later to run S_overrides.mk in a clean environment
our %SHELL_ENV = %ENV;

our $my_path;
BEGIN
{
    $my_path = $0 ;
    $my_path =~ s/trick-ify// ;
}

use File::Basename ;
use File::Find ;
use Getopt::Long ;
use Cwd ;
use lib "$my_path../libexec/trick/pm" ;
use get_makefile_vars ;

sub find_file_by_ext($$)
{
    my ($dirs_ref, $ext) = @_ ;
    our @files_found = ();
    my $wanted = sub
    {
        if($_ =~ /\Q$ext\E$/)
        {
            push @files_found, $File::Find::name ;
        }
    };
    find($wanted, @$dirs_ref);
}
our @files_found ;

sub exclude_paths($$)
{
    my ($file_refs, $excl) = @_ ;
    my @pruned_list ;
    foreach my $file (@$file_refs)
    {
        if(($file =~ /^\Q$excl\E/) ne 1)
        {
            push @pruned_list, $file ;
        }
    }
    @$file_refs = @pruned_list ;
}

sub filter_paths($$)
{
    my ($file_refs, $filters) = @_ ;
    if(@$filters eq 0)
    {
       return 0 ;
    }

    my @pruned_list ;
    foreach my $file (@$file_refs)
    {
        my $include = 0 ;
        foreach my $filter (@$filters)
        {
            if(($file =~ /^\Q$filter\E/) eq 1)
            {
                $include = 1 ;
            }
        }

        if($include)
        {
            push @pruned_list, $file ;
        }
    }
    @$file_refs = @pruned_list ;
}

our @header_ext = (".h", ".hh", ".hpp", ".H", ".hxx", ".h++") ;
our @source_ext = (".cpp", ".c", ".cc") ;
our @trick_build_files = ("build/", "buildmodels/", "DP_Product/", "makefile", "python", "S_main_Linux_8.5_x86_64.exe", "S_sie.resource", "S_source.hh", "trick.zip", ".trick") ;
our $tmp_trick_build = "trickifying_tmp" ;

my $build_dir = getcwd ;                                                     # Where to build trickify artifacts
my $source_dirs = "" ;                                                       # User source code directories
my $source_make_call = "" ;                                                  # Make call to build object files
my $source_make_args = "" ;                                                  # Args to pass into default object make
my $trickify_make_args = "" ;                                                # Arguments to pass into the trickify make
my $trickify_make_path = "$my_path../share/trick/makefiles/" ;               # Path of the trickify make file
my $full_build = 1 ;                                                         # Whether to build only ICG/Swig artifacts or entire source
my $name = "trickified" ;                                                    # Name of the library
my $build_type = "o" ;                                                       # Type of library to be built (o, a , so)
my $debug = 0 ;                                                              # Debug info flag
my $trick_home = "$my_path.." ;                                              # Trick directory to use for building
my $no_source_build = 0 ;                                                    # Arg to disable building source files
my $no_clean_obj = 0 ;                                                       # Don't rebuild trickify_obj_list
my $no_clean_src = 0 ;                                                       # Don't rebuild trickify_src_list
my $no_clean_s_source = 0 ;                                                  # Don't rebuild S_source.hh
my $s_overrides = "" ;                                                       # Optional S_override make file
my $include = "" ;                                                           # Directories to include when building source/ICG/SWIG files
my $exclude_arg = "" ;                                                       # Directories to exclude from trickification
my $s_define = "" ;                                                          # S_define to pull files from
my $s_define_filter = "" ;                                                   # Only use files from the S_define under these dirs

our $stage = 1;
sub logStage()
{
    open my $fh, '>>', "$build_dir/trickify_stage_$stage" ;
    $stage++ ;
}

GetOptions
(
    "d=s"                       => \$source_dirs,                    # User source code directories
    "no_clean_s_source"         => \$no_clean_s_source,              # Don't rebuild S_source.hh
    "no_clean_src_list"         => \$no_clean_src,                   # Don't rebuild trickify_src_list
    "no_clean_obj_list"         => \$no_clean_obj,                   # Don't rebuild trickify_obj_list
    "no_source"                 => \$no_source_build,                # Arg to disable building source files
    "source_make=s"             => \$source_make_call,               # Make call to build object files
    "source_make_args=s"        => \$source_make_args,               # Default make call args to build object files
    "trickify_args=s"           => \$trickify_make_args,             # Trickify make args
    "trickify_make=s"           => \$trickify_make_path,             # Set trickify make path
    "n=s"                       => \$name,                           # Set the library name
    "b=s"                       => \$build_type,                     # Set library build type
    "v"                         => \$debug,                          # Verbose, print debug info
    "trick_home=s"              => \$trick_home,                     # Set trick home directory
    "s_overrides=s"             => \$s_overrides,                    # Optional S_override make file
    "include=s"                 => \$include,                        # Directories to include when building source/ICG/SWIG files
    "ex=s"                      => \$exclude_arg,                    # Directories to exclude from trickification
    "build=s"                   => \$build_dir,                      # Where to build trickify artifacts
    "s_define=s"                => \$s_define,                       # S_define to pull files from
    "s_define_filter=s"         => \$s_define_filter                 # Only use files from the S_define under these dirs
) ;

# If we are trickifying, tells trick-CP to stop after trickify_deps is built
$ENV{'AM_I_TRICKIFYING'} = 1 ;
logStage(); #Stage 1

# If user provided an S_define, run a partial trick-CP and retrieve the lib dependencies
my $s_define_dir = "" ;
my @lib_deps_header;
my @lib_deps_source;
if($s_define ne "")
{
    $s_define_dir = dirname($s_define) ;
    chdir Cwd::abs_path($s_define_dir) or die "Error changing to the s_define directory: $s_define_dir\n" ;
    
    # If the user has already built the sim, push it somewhere else
    map 
    {
        if(-e $_)
        {
            system("mv $_ $tmp_trick_build$_") == 0 or die "Could not move $_\n" ;
        }
    }
    @trick_build_files;    

    my $cmd_ret = `$my_path/trick-CP 2>&1` ;
    if($cmd_ret ne "") 
    {
        print "$cmd_ret" ;
    }
    -e "build/trickify_deps" or die "Failed to create trickify_deps from S_define.\n" ;

    open (my $fh, "build/trickify_deps") or die "Could not open trickify_deps" ;
    while (my $line = <$fh>) 
    {
        chomp $line ;
        if($line =~ /\QS_source.hh\E$/)
        {
            next ;
        }
        if(scalar grep {$line =~ /\Q$_\E$/} @source_ext)
        {
            push @lib_deps_source, $line ;
        }
        else
        {
            push @lib_deps_header, $line ;
        }
    }
    close ($fh) ;

    # Clear up the partial build dir we just made
    system("make clean") == 0 or die "Could not clean up tmp build dir\n" ;

    map 
    {
        if(-e "$tmp_trick_build$_")
        {
            system("mv $tmp_trick_build$_ $_") == 0 or die "Could not move $_\n" ;
        }
    }
    @trick_build_files; 
}
my @filters = split ' ', $s_define_filter ;
filter_paths(\@lib_deps_source, \@filters) ;
filter_paths(\@lib_deps_header, \@filters) ;

chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;

# Split the s_overrides path into a dir and file name
my $s_overrides_dir  = "" ;
if ($s_overrides ne "")
{
    $s_overrides_dir  = dirname($s_overrides) ;
}

$full_build = !$no_source_build ;

if( !(($build_type eq "o") or ($build_type eq "a") or ($build_type eq "so") or ($build_type eq "dylib")) )
{
    print "Invalid build type {$build_type}, valid build types are {o, a, so}\n" ;
    exit 1 ;
}

if($s_define eq "")
{
    if($source_dirs eq "" and $full_build)
    {
        print "Must provide source directories or S_define\n" ;
        exit 1 ;
    }
}

#Build list of includes for compilation.
my $include_arg = "";
my @incl_dirs = split ' ', $include ;
foreach my $dir (@incl_dirs)
{
    $include_arg .= "-I$dir " ;
}

#Set Environment Variables
if ($full_build)
{
    $ENV{'FULL_TRICKIFY_BUILD'} = "1" ;
}
my @src_dirs = split ' ', $source_dirs ;
my $source_dir_args = "" ;
foreach my $dir (@src_dirs)
{
    $source_dir_args .= "-I" . $dir . " " ;
}
$ENV{'TRICKIFY_CXX_FLAGS'} = "$source_dir_args -I$trick_home -I$trick_home/include/trick/compat -I${trick_home}/include -I$trick_home/trick_source -I$trick_home/trick_source/er7_utils -I$trick_home/trick_source/er7_utils $include_arg " . $ENV{"TRICK_CFLAGS"} . " " . $ENV{"TRICK_CXXFLAGS"} ;
$ENV{'TRICKIFY_OBJECT_NAME'} = "$build_dir/$name.$build_type" ;
$ENV{'TRICKIFY_BUILD'} = "$build_dir/" ;
$ENV{'TRICKIFY_PYTHON_DIR'} = "$build_dir/python" ;
$ENV{'TRICKIFY_S_OVERRIDES'} = "$s_overrides" ;
our @exclude_list = split ' ', $exclude_arg ;
if ( $build_type eq "o" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "PLO" ;
}
elsif ( $build_type eq "a" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "STATIC" ;
}
elsif ( $build_type eq "so" || $build_type eq "dylib" )
{
    $ENV{'TRICKIFY_BUILD_TYPE'}  = "SHARED" ;
    if ($^O eq "linux")
    {
        $source_make_args .= " -fPIC" ;
    }
}

#Build the S_overrides_trickify.mk
print "Building S_overrides_trickify.mk\n" ;  
my $ext_lib_dir ;
$ext_lib_dir    .= join '', (map {":$_"} (split ' ', $source_dirs)) ;
$ext_lib_dir    .= join '', (map {":$_"} @filters) ;

#if the user provides an s_define, we automatically exclude that dir from ext_lib_dirs
if ($s_define_dir ne "")
{
    push @exclude_list, $s_define_dir ;
}

my $my_cwd = getcwd;
#TODO: Might want to add an option to make this a relative path.        
open (my $fh, ">", "S_overrides_trickify.mk") or die "Could not open S_overrides_trickify.mk\n" ;
print $fh "ifndef AM_I_TRICKIFYING\n" ;  # Only want these parameters if we are doing normal sim builds, otherwise the ext libs will butcher the trickify_deps
print $fh "LOCAL_DIR := \$(abspath \$(dir \$(lastword \$(MAKEFILE_LIST))))\n\n" ;
print $fh "TRICK_LDFLAGS += " . Cwd::abs_path($ENV{'TRICKIFY_OBJECT_NAME'}) . "\n" ;
print $fh "TRICK_EXT_LIB_DIRS += $ext_lib_dir\n" ;
print $fh "TRICK_EXT_LIB_DIRS_OVERRIDES += ", join '', (map {":$_"} @exclude_list) ,"\n" ;
print $fh "TRICK_PYTHON_PATH += :" . $my_cwd . "/python\n" ;
print $fh "TRICK_SWIG_FLAGS += -I" . $my_cwd . "\n" ;
print $fh "\nclean_trickify:\n" ;
print $fh "\t-make -C \$(LOCAL_DIR) clean_trickify\n" ;
print $fh "\nnuke_trickify:\n" ;
print $fh "\t-make -C \$(LOCAL_DIR) nuke_trickify\n" ;
print $fh "endif\n" ;
close ($fh) ;

open ($fh, ">", "makefile") or die "Could not create makefile\n" ;
print $fh "LOCAL_DIR := \$(abspath \$(dir \$(lastword \$(MAKEFILE_LIST))))\n" ;
print $fh "\nclean_trickify:\n" ;
print $fh "\t-rm -rf build .trick\n" ;
print $fh "\t-rm S_source.hh\n" ;
print $fh "\t-rm trickify_obj_list\n" ;
print $fh "\t-rm trickify_src_list\n" ;
print $fh "\t-rm trickify_stage_*\n" ;
print $fh "\t-rm trickify.log\n" ;
print $fh "\t-rm get_vars.mk\n" ;
print $fh "\t-rm var_dump.mk\n" ;
print $fh "\nnuke_trickify: clean_trickify\n" ;
print $fh "\t-rm python\n" ;
print $fh "\t-rm S_overrides_trickify.mk\n" ;
print $fh "\t-rm *.a\n" ;
print $fh "\t-rm *.o\n" ;
print $fh "\t-rm *.so\n" ;
print $fh "\t-rm makefile\n" ;
close ($fh) ;


#Build the S_source.hh
if (!$no_clean_s_source)
{
    print "Building S_source.hh\n" ;

    my @make_s_source ;
    my @headers = split ' ', $source_dirs ;
    foreach my $ext (@header_ext)
    {
        find_file_by_ext(\@headers, $ext) ;
        push @make_s_source, @files_found ;
    }
    push @make_s_source, @lib_deps_header ;

    foreach my $excl (@exclude_list)
    {
        exclude_paths(\@make_s_source, $excl) ;
    }

    open (my $fh, ">", "S_source.hh") or die "Could not open S_source.hh\n" ;
    foreach my $header (@make_s_source)
    {
        print $fh "#include \"$header\"\n" ;
    } 
}

#Build source file list, only if trickifying the entire library
if (!$no_clean_src and $full_build)
{
    print "Building trickify_src_list\n" ;

    my @make_src_list ;
    my @sources = split ' ', $source_dirs ;
    foreach my $ext (@source_ext)
    {
        find_file_by_ext(\@sources, $ext) ;
        push @make_src_list, @files_found ;
    }
    push @make_src_list, @lib_deps_source ;

    foreach my $excl (@exclude_list)
    {
        exclude_paths(\@make_src_list, $excl) ;
    }

    open (my $fh, ">", "trickify_src_list") or die "Could not open trickify_src_list\n" ;
    foreach my $source (@make_src_list)
    {
        print $fh "$source\n" ;
    }
}

#Build array of source files
#We need to read in the file we just wrote to, because there is a no_clean_src option
my @src_files ;
if ($full_build)
{
    open (my $fh, "trickify_src_list") or die "Could not open trickify_src_list: $!" ;
    while (my $line = <$fh>) 
    {
        chomp $line ;
        push @src_files, $line ;
    }
    close ($fh) ;
}
logStage(); #Stage 2

#Build object files from source file list
if ($full_build)
{
    print "Building object files\n" ;
    if($source_make_call eq "")
    {
        foreach my $src (@src_files)
        {
            my $cmd = "" ;
            $src =~ /^([\w\W]*\/)([\w\W^\/]*)$/ ;
            my $path = $1 ;
            my $file = $2 ;

            #create build directory
            my $cmd_rret = `mkdir -p build$path 2>&1`;
            if($debug)
            {
                if($cmd_rret ne "") 
                {
                    print "$cmd_rret" ;
                }
            }

            if($file =~ /\S\w*(\Q.c\E)$/)
            {
                $file =~ s/\Q.c\E$// ;
                #$cmd = "gcc $source_make_args $ENV{'TRICKIFY_CXX_FLAGS'} -c $src -o build$path$file.o" ;
                $cmd = "make C -f $trickify_make_path/trickify_src.mk" ;
                $ENV{'TRICKIFY_SRC_MAKE_ARGS'} = $source_make_args ;
                $ENV{'TRICKIFY_SRC_MAKE_SRC'}  = $src ;
                $ENV{'TRICKIFY_SRC_MAKE_OBJ'}  = "$build_dir/build$path$file.o" ;
            }
            else
            {
                $file =~ s/\Q.\E\w*$// ; 
                #$cmd = "g++ $source_make_args $ENV{'TRICKIFY_CXX_FLAGS'} -c $src -o build$path$file.o" ;
                $cmd = "make CPP -f $trickify_make_path/trickify_src.mk" ;
                $ENV{'TRICKIFY_SRC_MAKE_ARGS'} = $source_make_args ;
                $ENV{'TRICKIFY_SRC_MAKE_SRC'}  = $src ;
                $ENV{'TRICKIFY_SRC_MAKE_OBJ'}  = "$build_dir/build$path$file.o" ;
            }
            if($debug)
            {
                print "Building obj file: $cmd\n" ;
            }

            #If an s_overrides.mk is provided we need to build in that dir to preserve relative make paths
            if($s_overrides_dir ne "")
            {
                chdir Cwd::abs_path($s_overrides_dir) or die "Error changing to s_overrides directory: $s_overrides_dir\n" ;
            }
            my $cmd_ret = `$cmd 2>&1` ;
            if($cmd_ret ne "") 
            {
                print "$cmd_ret" ;
            }
            chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;
        }
    }
    else
    {
        print(`$source_make_call`) ;
    }
}

#Build object file list, only if trickifying the entire library
if(!$no_clean_obj and $full_build)
{
    print "Building trickify_obj_list\n" ;
    #Create list of source file names without dirs and extensions
    my @src_files_base ;
    foreach my $src (@src_files)
    {
        $src =~ s/\..*$// ;
        push @src_files_base, basename($src) ;
    }

    #Create a list of all .o files under build
    my @make_obj_list ;
    my @build_dir = getcwd ;
    find_file_by_ext(\@build_dir, ".o") ;
    push @make_obj_list, @files_found ;

    open (my $fh, ">", "trickify_obj_list") or die "Could not open trickify_obj_list\n" ;
    foreach my $obj (@make_obj_list)
    {
        #remove the dir and extension
        $obj =~ /^(.+?)\Q.o\E$/ ;
        my $raw_filename = $1 ;
        $raw_filename = basename($raw_filename) ;
        
        #only write .o that have a matching source file
        #this ensures we don't grab swig and icg .o artifacts twice, those are pulled in later
        my @is_present = grep (/\Q$raw_filename\E/, @src_files_base) ;
        if(@is_present ne 0)
        {
            print $fh "$obj\n" ;
        }
    } 
}
logStage(); #Stage 3

#Build trickify call
print "Begin Trickification...\n" ;
if($s_overrides_dir ne "")
{
    chdir Cwd::abs_path($s_overrides_dir) or die "Error changing to s_overrides directory: $s_overrides_dir\n" ;
    dump_makefile_vars($s_overrides, $build_dir, \%SHELL_ENV, ("TRICKIFY_BUILD_TYPE", "TRICKIFY_OBJECT_NAME", "TRICKIFY_PYTHON_DIR", "TRICK_CFLAGS", "TRICK_CXXFLAGS")) ; 
    chdir Cwd::abs_path($build_dir) or die "Error changing to build directory: $build_dir\n" ;
    $ENV{"TRICKIFY_MAKE_DUMP"} = Cwd::abs_path("var_dump.mk") ;
}
my $trickify_make_call = "make $trickify_make_args -f $trickify_make_path/trickify.mk trickify" ;
my $cmd_ret = `$trickify_make_call 2>&1` ;
my $cmd_exit_code = $? ;
if($cmd_ret ne "") 
{
    print "$cmd_ret" ;
}
logStage(); #Stage 4

if($debug) {
    print 
   "TRICKIFY BUILD INFO:
    source_dirs = $source_dirs
    source_make_call = $source_make_call
    trickify_make_args = $trickify_make_args
    trickify_make_path = $trickify_make_path
    build_s_source = $no_clean_s_source
    full_build = $full_build
    name = $name
    build_type = $build_type
    trick_home = $trick_home
    TRICKIFY_CXX_FLAGS = $ENV{'TRICKIFY_CXX_FLAGS'}\n" ;
}

if($cmd_exit_code != 0)
{
    die $cmd_exit_code ;
}
